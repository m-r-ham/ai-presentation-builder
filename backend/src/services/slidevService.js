const fs = require('fs').promises;
const path = require('path');
const { spawn } = require('child_process');

class SlidevService {
  constructor() {
    this.slidevProjectPath = path.join(__dirname, '../../../slidev-presentations');
    this.presentationsDir = path.join(__dirname, '../../presentations');
  }

  // Generate complete Slidev presentation from slides
  async generatePresentation(presentationData) {
    try {
      const { title, slides, metadata } = presentationData;
      
      // Generate frontmatter
      const frontmatter = this.generateFrontmatter(title, metadata);
      
      // Combine all slide markdown
      const slidesMarkdown = slides.map(slide => {
        // Extract the content part (without frontmatter) if slidevMarkdown includes it
        if (slide.slidevMarkdown) {
          const content = slide.slidevMarkdown.replace(/^---[\s\S]*?---\n/, '');
          return content.trim();
        }
        
        // Fallback: generate basic markdown from slide data
        return this.generateFallbackSlideMarkdown(slide);
      }).join('\n\n---\n\n');

      // Complete presentation markdown
      const fullMarkdown = `${frontmatter}\n\n${slidesMarkdown}`;
      
      return {
        markdown: fullMarkdown,
        slideCount: slides.length,
        generatedAt: new Date().toISOString()
      };
    } catch (error) {
      console.error('Error generating Slidev presentation:', error);
      throw error;
    }
  }

  // Generate Slidev frontmatter
  generateFrontmatter(title, metadata = {}) {
    const theme = metadata.theme || 'default';
    const transition = metadata.transition || 'slide-left';
    
    return `---
theme: ${theme}
title: ${title || 'AI Generated Presentation'}
info: |
  ## ${title || 'Presentation'}
  Generated by AI Presentation Builder with design training insights
class: text-center
transition: ${transition}
mdc: true
download: true
exportFilename: ${this.slugify(title || 'presentation')}
---`;
  }

  // Generate fallback markdown for slides without Slidev markdown
  generateFallbackSlideMarkdown(slide) {
    const { title, description, keyPoints, type } = slide;
    
    // Choose layout based on slide type and content
    let layout = 'default';
    let layoutLine = '';
    
    if (type === 'title') {
      layout = 'cover';
      layoutLine = `layout: ${layout}\nclass: text-center\n`;
    } else if (type === 'summary') {
      layout = 'end';
      layoutLine = `layout: ${layout}\n`;
    } else if (keyPoints && keyPoints.length > 0) {
      layout = 'default';
    }

    let content = '';
    if (layoutLine) {
      content += `---\n${layoutLine}---\n\n`;
    }

    content += `# ${title}\n\n`;
    
    if (description) {
      content += `${description}\n\n`;
    }
    
    if (keyPoints && keyPoints.length > 0) {
      keyPoints.forEach(point => {
        content += `- ${point}\n`;
      });
    }

    return content;
  }

  // Save presentation to file system
  async savePresentation(presentationId, markdown) {
    try {
      await fs.mkdir(this.presentationsDir, { recursive: true });
      
      const filename = `${presentationId}.md`;
      const filepath = path.join(this.presentationsDir, filename);
      
      await fs.writeFile(filepath, markdown, 'utf8');
      
      return {
        filepath,
        filename,
        url: `/api/presentations/${filename}`
      };
    } catch (error) {
      console.error('Error saving presentation:', error);
      throw error;
    }
  }

  // Export presentation to PDF/PNG/PPTX
  async exportPresentation(presentationId, format = 'pdf') {
    try {
      const inputFile = path.join(this.presentationsDir, `${presentationId}.md`);
      const outputDir = path.join(this.presentationsDir, 'exports');
      
      await fs.mkdir(outputDir, { recursive: true });
      
      const outputFile = path.join(outputDir, `${presentationId}.${format}`);
      
      // Use Slidev CLI to export
      const slidevArgs = [
        'export',
        inputFile,
        '--format', format,
        '--output', outputFile
      ];

      return new Promise((resolve, reject) => {
        const slidevProcess = spawn('npx', ['slidev', ...slidevArgs], {
          cwd: this.slidevProjectPath,
          stdio: 'pipe'
        });

        let output = '';
        let error = '';

        slidevProcess.stdout.on('data', (data) => {
          output += data.toString();
        });

        slidevProcess.stderr.on('data', (data) => {
          error += data.toString();
        });

        slidevProcess.on('close', (code) => {
          if (code === 0) {
            resolve({
              success: true,
              outputFile,
              format,
              output
            });
          } else {
            reject(new Error(`Slidev export failed: ${error}`));
          }
        });

        slidevProcess.on('error', (err) => {
          reject(new Error(`Failed to spawn Slidev process: ${err.message}`));
        });
      });
    } catch (error) {
      console.error('Error exporting presentation:', error);
      throw error;
    }
  }

  // Preview presentation in Slidev dev server
  async previewPresentation(presentationId) {
    try {
      const inputFile = path.join(this.presentationsDir, `${presentationId}.md`);
      
      // Copy to slidev project for preview
      const slidevFile = path.join(this.slidevProjectPath, 'slides.md');
      const markdown = await fs.readFile(inputFile, 'utf8');
      await fs.writeFile(slidevFile, markdown, 'utf8');
      
      // Slidev dev server should automatically reload
      return {
        success: true,
        previewUrl: 'http://localhost:3002',
        presenterUrl: 'http://localhost:3002/presenter',
        overviewUrl: 'http://localhost:3002/overview'
      };
    } catch (error) {
      console.error('Error previewing presentation:', error);
      throw error;
    }
  }

  // Utility: Convert title to URL-friendly slug
  slugify(text) {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  // Get list of saved presentations
  async listPresentations() {
    try {
      const files = await fs.readdir(this.presentationsDir);
      const presentations = [];

      for (const file of files) {
        if (file.endsWith('.md')) {
          const filepath = path.join(this.presentationsDir, file);
          const stats = await fs.stat(filepath);
          const content = await fs.readFile(filepath, 'utf8');
          
          // Extract title from frontmatter
          const titleMatch = content.match(/title:\s*(.+)/);
          const title = titleMatch ? titleMatch[1] : path.basename(file, '.md');
          
          presentations.push({
            id: path.basename(file, '.md'),
            title,
            filename: file,
            createdAt: stats.birthtime,
            modifiedAt: stats.mtime,
            size: stats.size
          });
        }
      }

      return presentations.sort((a, b) => b.modifiedAt - a.modifiedAt);
    } catch (error) {
      console.error('Error listing presentations:', error);
      return [];
    }
  }
}

module.exports = SlidevService;